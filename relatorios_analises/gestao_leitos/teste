
from datetime import datetime
import json
import schedule
import time
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

class paciente:
    def __init__(self, nome, idade, sexo, historico, contato, gravidade, ingresso, horario, id_paciente, limiteVisitantes, condicao_diagnostico,leito ):
        self.nome = nome
        self.idade = idade
        self.sexo = sexo
        self.historico = historico
        self.contato = contato
        self.gravidade = gravidade
        self.ingresso = ingresso
        self.id_paciente = id_paciente
        self.limiteVisitantes = limiteVisitantes 
        self.condicao_diagnostico = condicao_diagnostico
        self.horario = horario

        
class Ala:
    def __init__(self,tipo_ala,num_leitos):
        #numero de leitos em cada ala
        self.num_leitos = num_leitos
        #que tipo de ala o paciente vai ficar 
        self.tipo_ala = tipo_ala
        
        self.dados_ala = {
            'leitos': [],
            'historico_ocupacao' : []
        }
        
        #leitos vão ser criados automaticamente 
        for i in range(1,num_leitos + 1):
            leito = {
                'tipo_ala': self.tipo_ala,
                'num_do_leito' : i,
                'status' : 'livre',
                'IDpaciente':None,
                'gravidade': ''
            }
            #adicionar o leito novo a lista leitos 
            self.dados_ala['leitos'].append(leito)
        self.salvar_dados_em_arquivo(f'{self.tipo_ala}.txt')    
            
    def salvar_dados_em_arquivo(self,arquivo):
        with open(f"{arquivo}.txt","w") as arquiv:
            json.dump(self.dados_ala,arquiv)
            
    def ocupar_leito(self,num_leito,IDpaciente,gravidade):
        leitos_disponiveis = [
            leito for leito in self.dados_ala['leitos']
            if leito['status'] == 'livre'
        ]
        if not leitos_disponiveis:
            return "nenhum leito disponível"
        leitos_disponiveis.sort(key=lambda leito: gravidade.index(leito['gravidade']))
        for leito in leitos_disponiveis:
            if leito['num_do_leito'] == num_leito:
                leito['status'] = 'ocupado'
                leito['IDpaciente'] = IDpaciente              
                hist_leito = leito.copy()
                self.dados_ala['historico_ocupacao'].append(hist_leito)
                
                self.salvar_dados_em_arquivo(f"{self.tipo_ala}.txt")
                return f"leito {num_leito} reservado para o paciente {IDpaciente}."
            
        return f"Leito {num_leito} não disponível ou já ocupado."
    
    def ler_historico_ocupacao(self):
        return self.dados_ala['historico_ocupacao']
    
    def gerar_relatorio_periodico(self):
        data_hora = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        relatorio = f"Relatório de ocupação de leitos - {data_hora}\n"

        estatisticas = self.calcular_estatisticas_da_ala()
        relatorio += f"\n{self.tipo_ala}:\n{estatisticas}"

        with open(f"relatorio_{self.tipo_ala}.txt", "a") as arquivo:
            arquivo.write(relatorio)

    def calcular_estatisticas_da_ala(self):
        leitos_ocupados = sum(1 for leito in self.dados_ala['leitos'] if leito['status'] == 'ocupado')
        leitos_livres = sum(1 for leito in self.dados_ala['leitos'] if leito['status'] == 'livre')
        total_leitos = len(self.dados_ala['leitos'])
        taxa_ocupacao = (leitos_ocupados / total_leitos) * 100
        estatisticas = f"Total de leitos: {total_leitos}\n"
        estatisticas += f"Leitos ocupados: {leitos_ocupados}\n"
        estatisticas += f"Leitos livres: {leitos_livres}\n"
        estatisticas += f"Taxa de ocupação: {taxa_ocupacao:.2f}%"
        return estatisticas
    def liberar_leito(self,num_leito):
        for leito in self.dados_ala['leitos']:
            if leito['num_do_leito'] == num_leito and leito['status'] == 'ocupado':
                leito['status'] = 'livre'
                leito['IDpaciente'] = None
                self.salvar_dados_em_arquivo(f"{self.tipo_ala}.txt")
                return f"Leito {num_leito} desocupado com sucesso."
        return f"Leito {num_leito} não está ocupado ou não existe na ala."
            
            
class TempReal(FileSystemEventHandler):
    def __init__(self, log_file="registros_alas.log"):
        self.log_file = log_file
        
    def esta_modificado(self,event):
         if hasattr(event, 'is_directory') and not event.is_directory:
            with open(f"{event.src_path}",'r') as arquivo:
                data = arquivo.read()
                
            if "leito reservado" in data:
                with open(f"{self.log_file}","a") as log:
                    log.write("Operação de reserva de leito: " + data) 
                    
            if "Leito liberado" in data:
                with open(f"{self.log_file}", "a") as log:
                    log.write("Operação de liberação de leito: " + data)   
        
        
        
def main():
    temp_real = TempReal(log_file="registros_alas.log")

    #teste de alas 
    uti = Ala('UTI', 10)
    ala1 = Ala('ala1', 15)
    ala2 = Ala('ala2', 20)
    while True:
        schedule.run_pending()
        time.sleep(1)
        print("-----menu de gestão de leitos-----")
        print("Escolha uma opção:")
        print("[1] Ocupar leito")
        print("[2] Liberar leito")
        print("[3] ler histórico de ocupação")
        print("[4] acessar relatórios de ocupação")
        print("[5] Sair")
        escolha = int(input("Opção: "))
        if escolha == 1:
        #tipo_ala, paciente
            ala = input("Insira o nome da ala [ala1,ala2,UTI]: ")
            id_p = input("Insira o ID do paciente: ")
            grav = input("Insira a gravidade do paciente: ")
            if ala == 'UTI':
                evento_modificado = uti.ocupar_leito(ala,id_p,grav)
                temp_real.esta_modificado(evento_modificado)
            
            elif ala == 'ala1':
                evento_modificado = ala1.ocupar_leito(ala,id_p,grav)
                temp_real.esta_modificado(evento_modificado)
                
            elif ala == 'ala2':
                evento_modificado = ala2.ocupar_leito(ala,id_p,grav)
                temp_real.esta_modificado(evento_modificado)
                
                
                
        elif escolha == 2:
            ala = input("Insira o nome da ala [ala1,ala2,UTI]: ")
            num_leito = int(input("Insira o numero do leito a ser liberado"))
            if ala == 'UTI':
                evento_modificado = uti.liberar_leito(num_leito)
                temp_real.esta_modificado(evento_modificado)
                
            elif ala == 'ala1':
                evento_modificado = ala1.liberar_leito(num_leito)
                temp_real.esta_modificado(evento_modificado)
                
            elif ala == 'ala2':
                evento_modificado = ala2.liberar_leito(num_leito)
                temp_real.esta_modificado(evento_modificado)
                
                
        elif escolha == 3:
            ala = input("Insira o nome da ala [ala1,ala2,UTI]: ")
            if ala == 'UTI':
                historico = uti.ler_historico_ocupacao()
                print(historico)
                for registro in historico:
                    print(registro)

                      
            elif ala == 'ala1':
                histala1 = ala1.ler_historico_ocupacao()
                print(histala1)
                print("historico de ocupação da ala 1: ")
                for registro in histala1:
                    print(registro)
                    
            elif ala == 'ala2':
                histala2 = ala2.ler_historico_ocupacao()
                print(histala2)
                print("historico de ocupação da ala 2")
                for registro in histala2:
                    print(registro)
                    
        elif escolha == 4:
             for ala in [uti, ala1, ala2]:
                ala.gerar_relatorio_periodico()              
                    
        elif escolha == 5:
            break
                
                
                 
main()